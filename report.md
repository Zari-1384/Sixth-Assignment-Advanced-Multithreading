سوال اول :
خروجی :
Calling run()
Running in: main
Calling start()
Running in: Thread-2

تفاوت دستور run و start  :
وقتی مستقیما از دستور run استفاده میکنیم در واقع داریم متد run رو فقط صدا میکنیم و روی main اجرا میکنیم، به همین دلیل در خروجی اول میگه که کد روی main درحال ران شدنه
ولی وقتی از start استفاده میکنیم یک ترد جدید ساخته میشه و متد ران از روی ترد اجرا میشه، بخاطر همین در خروجی دوم میگه کد روی ترد 2 درحال ران شدنه.




سوال دوم : 
۱. خروجی برنامه چه خواهد بود؟ چرا؟

خروجی کد احتمالا به این شکل خواهد بود :
Daemon thread running...
Daemon thread running...
Main thread ends.

البته درباره تعداد چاپ شدن Daemon thread running... تضمین دقیقی وجود ندارد، اما حداکثر دو تا سه بار خواهد بود.


۲. اگر thread.setDaemon(true) را برداریم چه اتفاقی می‌افتد؟

در آن صورت دیگر ترد deamon نخواهد بود و تبدیل به یک ترد عادی میشود و حتی بعد از اتمام ترد main بازهم به کار خود تا انتها ادامه میدهد و تا 20 بار را چاپ خواهد کرد.


۳. کاربردهای واقعی نخ‌های daemon چیست؟

. گردآوری زباله (Garbage Collector) در داخل JVM.
. نخ‌های «نگهبان» (watchdog) که فقط تا زمانی که برنامهٔ اصلی زنده است فعالیت می‌کنند.




سوال سوم : 

1. خروجی این برنامه چیست؟

Thread is running using a ...!

2. عبارت () -> { ... } چه نام دارد؟

این سینتکس در جاوا Lambda Expression (عبارت لامبدا) نامیده می‌شود.

3. این کد چه تفاوتی با ساخت کلاس جداگانه‌ای که Thread را extend می‌کند یا Runnable را implements می‌کند دارد؟

اگر بخواهیم توی کلاس جداگانه این کارها رو انجام بدیم کدمون طولانی تر میشه
ولی با استفاده از لامبادا وقتهایی که فقط برای interfaceهایی با یک متد (مانند Runnable) کار داریم استفاده میشن و میتونیم یک متد ران رو تعریف کنیم، کدش رو بسازیم، ترد ازش بسازیم و اجراش کنیم و همه اینها توی چندتا خط کوتاه و به شکل پشت سر هم انجام میشه
در واقع کد رو خیلی کوتاه تر و خلاصه تر میکنه، ولی برای وقتهایی مناسبه که متد ران خیلی پیچیده نیست. برای موارد پیچیده بهتره از همون روش قدیمی استفاده کنیم
